---
title: "Forecasts from METR time horizons are prior-driven: A Bayesian analysis"
author: "Jonas Moss"
date: "2026-02-13"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    code-tools: true
    theme: cosmo
    embed-resources: true
  pdf:
    toc: true
    toc-depth: 3
  gfm:
    variant: +footnotes+tex_math_dollars
execute:
  echo: true
  warning: false
  freeze: auto
jupyter: python3
---

```{python}
# | echo: false
# | output: false
# | label: setup

import json
import math
from pathlib import Path

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime

# ---------------------------------------------------------------------------
# Paths & specs
# ---------------------------------------------------------------------------
RUNS_ROOT = Path("outputs/runs")

SPECS = {
    "Linear": "time_irt__theta_linear",
    "Quadratic": "time_irt__theta_quadratic_pos",
    "Power-law": "time_irt__theta_xpow",
    "Saturating": "time_irt__theta_theta_logistic",
}

SPEC_COLORS = {
    "Linear": "C0",
    "Quadratic": "C1",
    "Power-law": "C2",
    "Saturating": "C3",
}


def resolve_latest(spec: str) -> Path:
    """Return the concrete run directory for a spec (reads LATEST pointer)."""
    spec_dir = RUNS_ROOT / spec
    run_id = (spec_dir / "LATEST").read_text().strip()
    return spec_dir / run_id


def figdir(spec: str) -> Path:
    return resolve_latest(spec) / "figures"


def diagdir(spec: str) -> Path:
    return resolve_latest(spec) / "diagnostics"


# ---------------------------------------------------------------------------
# Utility functions (from scripts/make_figures.py)
# ---------------------------------------------------------------------------
def logistic(x):
    return 1.0 / (1.0 + np.exp(-np.asarray(x, dtype=float)))


def logit(p):
    return math.log(p / (1.0 - p))


def _format_duration_hours(hours: float) -> str:
    if not np.isfinite(hours) or hours <= 0:
        return ""
    seconds = hours * 3600.0
    if seconds < 60:
        return f"{int(round(seconds))} sec"
    minutes = seconds / 60.0
    if minutes < 60:
        return f"{int(round(minutes))} min"
    if hours < 24:
        v = int(round(hours))
        return f"{v} hour" if v == 1 else f"{v} hours"
    days = hours / 24.0
    if days >= 365:
        years = int(round(days / 365.0))
        return f"{years} year" if years == 1 else f"{years} years"
    if days >= 30:
        months = int(round(days / 30.0))
        return f"{months} month" if months == 1 else f"{months} months"
    v = int(round(days))
    return f"{v} day" if v == 1 else f"{v} days"


def apply_metr_duration_ticks(ax, y_values_hours):
    y = np.asarray(y_values_hours, dtype=float)
    y = y[np.isfinite(y) & (y > 0)]
    if y.size == 0:
        return
    ymin, ymax = float(np.min(y)), float(np.max(y))
    if ymin <= 0 or ymax <= 0:
        return
    ticks = np.array(
        [
            4 / 3600,
            36 / 3600,
            6 / 60,
            1.0,
            10.0,
            4 * 24.0,
            30 * 24.0,
            6 * 30 * 24.0,
            3 * 365 * 24.0,
            18 * 365 * 24.0,
            50 * 365 * 24.0,
            100 * 365 * 24.0,
            500 * 365 * 24.0,
        ]
    )
    lo, hi = ymin / 1.15, ymax * 1.15
    keep = ticks[(ticks >= lo) & (ticks <= hi)]
    if keep.size < 3:
        below = ticks[ticks < lo]
        above = ticks[ticks > hi]
        candidates = []
        if below.size:
            candidates.append(below[-1])
        candidates.extend(keep.tolist())
        if above.size:
            candidates.append(above[0])
        keep = np.array(candidates, dtype=float)
    if keep.size == 0:
        return
    ax.set_yticks(keep)
    ax.set_yticklabels([_format_duration_hours(float(t)) for t in keep])
    ax.grid(True, which="major", axis="y", linestyle="--", linewidth=0.8, alpha=0.25)


# ---------------------------------------------------------------------------
# Data loaders
# ---------------------------------------------------------------------------
def load_theta_points(spec: str) -> pd.DataFrame:
    df = pd.read_csv(figdir(spec) / "theta_points.csv")
    df["release_date"] = pd.to_datetime(df["release_date"])
    return df


def load_theta_trend(spec: str) -> pd.DataFrame:
    df = pd.read_csv(figdir(spec) / "theta_trend_grid.csv")
    df["date"] = pd.to_datetime(df["date"])
    return df


def load_horizon_grid(spec: str, kind: str = "marginal") -> pd.DataFrame:
    fname = "horizon_grid.csv" if kind == "marginal" else "horizon_grid_typical.csv"
    df = pd.read_csv(figdir(spec) / fname)
    df["date"] = pd.to_datetime(df["date"])
    return df


def load_horizon_points(spec: str, kind: str = "marginal") -> pd.DataFrame:
    fname = "horizon_points.csv" if kind == "marginal" else "horizon_points_typical.csv"
    df = pd.read_csv(figdir(spec) / fname)
    df["release_date"] = pd.to_datetime(df["release_date"])
    return df


def load_meta(spec: str) -> dict:
    return json.loads((resolve_latest(spec) / "fit" / "meta.json").read_text())


# ---------------------------------------------------------------------------
# Plot defaults
# ---------------------------------------------------------------------------
plt.rcParams.update(
    {
        "figure.facecolor": "white",
        "axes.facecolor": "white",
        "font.size": 11,
        "axes.titlesize": 13,
        "axes.labelsize": 12,
    }
)
```

```{python}
# | echo: false
# | output: false
# | label: precompute

from scipy.stats import gaussian_kde

# Doubling-time draws (months)
_dt_draws = pd.read_csv(
    figdir("time_irt__theta_linear") / "doubling_time_draws.csv"
)
dt_months = _dt_draws["doubling_time_years"].values * 12
dt_q025, dt_q50, dt_q975 = np.percentile(dt_months, [2.5, 50, 97.5])

# Key IRT parameters from linear model
_meta_lin = load_meta("time_irt__theta_linear")
_sp = _meta_lin["scalar_params"]
sigma_b_q50 = _sp["sigma_b"]["q50"]
kappa_q50 = _sp["kappa"]["q50"]
mean_log_t_hours = _meta_lin["mean_log_t_hours"]
difficulty_time_mult = np.exp(sigma_b_q50 / kappa_q50)

# 125-year crossing dates for TLDR
_df125_pre = pd.read_csv("blog/_generated/125y_horizon.csv")

def _crossing_cri(df, trend):
    r = df[df["theta_trend"] == trend].iloc[0]
    lo = pd.to_datetime(r["ci95_low"])
    hi = pd.to_datetime(r["ci95_high"])
    if lo.day >= 15:
        lo += pd.offsets.MonthBegin(1)
    if hi.day >= 15:
        hi += pd.offsets.MonthBegin(1)
    return lo.strftime("%Y-%m"), hi.strftime("%Y-%m")

cross125_lin_lo, cross125_lin_hi = _crossing_cri(_df125_pre, "linear")
cross125_quad_lo, cross125_quad_hi = _crossing_cri(_df125_pre, "quadratic_pos")

# Frontier model's marginal 80% horizon
_hpts_marg80 = load_horizon_points("time_irt__theta_linear", kind="marginal")
_hpts_marg80 = _hpts_marg80.query("p == 0.8").sort_values("release_date")
frontier_80_marg_minutes = _hpts_marg80.iloc[-1]["t_hours_q50"] * 60

# Claude 3.7 Sonnet 80% horizons (for comparison with METR's reported ~15 min)
_metr_sonnet37_80_min = 15.0
_sonnet37_marg = _hpts_marg80[_hpts_marg80["model"].str.contains("3_7_sonnet")]
_hpts_typ80 = load_horizon_points("time_irt__theta_linear", kind="typical")
_hpts_typ80 = _hpts_typ80.query("p == 0.8")
_sonnet37_typ = _hpts_typ80[_hpts_typ80["model"].str.contains("3_7_sonnet")]
sonnet37_marg_min = _sonnet37_marg.iloc[0]["t_hours_q50"] * 60
sonnet37_typ_min = _sonnet37_typ.iloc[0]["t_hours_q50"] * 60

# Scenario: 125-year 80% crossing, marginal vs typical
_df_marg_125_sc = pd.read_csv("blog/_generated/125y_horizon_p80_marginal.csv")
_df_typ_125_sc = pd.read_csv("blog/_generated/125y_horizon_p80_typical.csv")

def _mean_crossing_date(df, trend):
    return pd.to_datetime(df[df["theta_trend"] == trend].iloc[0]["mean_date"])

def _approx_month_year(ts):
    if ts.day >= 15:
        ts += pd.offsets.MonthBegin(1)
    return ts.strftime("%B %Y")

_marg_q = _mean_crossing_date(_df_marg_125_sc, "quadratic_pos")
_marg_p = _mean_crossing_date(_df_marg_125_sc, "xpow")
scenario_marg = _marg_q + (_marg_p - _marg_q) / 2
scenario_marg_str = _approx_month_year(scenario_marg)

_typ_q = _mean_crossing_date(_df_typ_125_sc, "quadratic_pos")
_typ_p = _mean_crossing_date(_df_typ_125_sc, "xpow")
scenario_typ = _typ_q + (_typ_p - _typ_q) / 2
scenario_typ_str = _approx_month_year(scenario_typ)

scenario_diff_years = abs((scenario_marg - scenario_typ).days) / 365.25

_marg_lin_125 = _mean_crossing_date(_df_marg_125_sc, "linear")
_typ_lin_125 = _mean_crossing_date(_df_typ_125_sc, "linear")
linear_diff_years = abs((_marg_lin_125 - _typ_lin_125).days) / 365.25
```

## TLDR
I reanalyzed the METR task data using a Bayesian item response theory model. 

* **The METR data cannot distinguish exponential from superexponential growth.** Four trajectory shapes (linear, quadratic, power-law, saturating) fit the existing data equally well but diverge on forecasts. For instance, the 95% credible interval for the 125-year crossing is `{python} cross125_lin_lo` – `{python} cross125_lin_hi` for linear and `{python} cross125_quad_lo` – `{python} cross125_quad_hi` for quadratic.
* **METR's headline horizon numbers overstate current capability by roughly an order of magnitude at 80% success.** METR doesn't model variation in task difficulty, so their horizons reflect a task of typical difficulty for its length. But tasks of the same length vary a lot in how hard they are, and at 80% success the hard ones dominate. Curiously, this doesn't affect timelines by more than ~1 year, as it's just a level-shift.
* **We need data about the human times to quantify uncertainty.** Credible intervals throughout are too narrow because I treat human times as known rather than estimating them as latent variables. I'm doing this because I don't have access to all the raw data. This could be a big deal, and could also affect the $80\%$ horizons.
* Doubling time under the standard linear (exponential growth) model is ~`{python} f"{dt_q50:.1f}"` months, which is similar to METR's estimate (95% credible interval: `{python} f"{dt_q025:.1f}"`–`{python} f"{dt_q975:.1f}"`, but see caveat above).

## METR data

Let's start with a plot that shouldn't be too surprising. Four reasonable models fit the [METR data](https://github.com/METR/eval-analysis-public/tree/main/reports/time-horizon-1-1/data/raw) equally well. They agree about the past but disagree strongly about the future.


```{python}
# | label: fig-horizon-fan
# | fig-cap: "50%-success horizon vs. release date under four trajectory models."
# | echo: false

fig, ax = plt.subplots(figsize=(9.5, 3.8))

x_max = pd.Timestamp("2029-01-01")

for label, spec_name in SPECS.items():
    g = load_horizon_grid(spec_name).query("p == 0.5").sort_values("date")
    g = g[g["date"] <= x_max]
    ax.plot(
        g["date"], g["t_hours_q50"], color=SPEC_COLORS[label], linewidth=2, label=label
    )
    ax.fill_between(
        g["date"],
        g["t_hours_q025"],
        g["t_hours_q975"],
        color=SPEC_COLORS[label],
        alpha=0.10,
    )

# Model-specific horizon points.
hpts = load_horizon_points(list(SPECS.values())[0]).query("p == 0.5")
ax.errorbar(
    hpts["release_date"],
    hpts["t_hours_q50"],
    yerr=np.vstack(
        [
            hpts["t_hours_q50"] - hpts["t_hours_q025"],
            hpts["t_hours_q975"] - hpts["t_hours_q50"],
        ]
    ),
    fmt="o",
    color="black",
    ecolor="0.35",
    elinewidth=1.5,
    capsize=3,
    alpha=0.7,
    zorder=5,
    markersize=5,
)

# Label a few key models.
LABELS_TO_SHOW = {
    "gpt_4o_inspect": ("GPT-4o", (8, -8)),
    "claude_3_5_sonnet_20241022_inspect": ("Sonnet 3.5 (new)", (8, -8)),
    "claude_opus_4_5_inspect": ("Opus 4.5", (8, 0)),
}
for _, r in hpts.iterrows():
    if r["model"] in LABELS_TO_SHOW:
        txt, ofs = LABELS_TO_SHOW[r["model"]]
        ax.annotate(
            txt,
            (r["release_date"], r["t_hours_q50"]),
            textcoords="offset points",
            xytext=ofs,
            fontsize=7.5,
            color="0.3",
            va="center",
        )

# 1-month reference line.
ax.axhline(
    30 * 24, color="red", linestyle="--", alpha=0.5, linewidth=1.5, label="1 month"
)

ax.set_yscale("log")
ax.set_xlabel("Release date")
ax.set_title("50%-success horizon vs. release date")
ax.set_xlim(pd.Timestamp("2023-01-01"), x_max)
ax.set_ylim(0.03, 365 * 24)  # ~2 min to 1 year
ax.xaxis.set_major_locator(mdates.YearLocator())
ax.xaxis.set_major_formatter(mdates.DateFormatter("%Y"))

# Duration ticks within the visible range.
tick_hours = np.array(
    [
        6 / 60,
        1.0,
        10.0,
        4 * 24.0,
        30 * 24.0,
        6 * 30 * 24.0,
    ]
)
ax.set_yticks(tick_hours)
ax.set_yticklabels([_format_duration_hours(float(t)) for t in tick_hours])
ax.grid(True, which="major", axis="y", linestyle="--", linewidth=0.8, alpha=0.25)

ax.legend(fontsize=8, loc="upper left")
fig.tight_layout()
plt.show()
```

The model selection scores known as ELPD-LOO differ by at most ~7 points.^[The ELPD-LOO estimates are: linear $-2191.9$ (SE $70.1$), saturating $-2195.9$ (SE $70.2$), power-law $-2197.0$ (SE $70.1$), quadratic $-2198.7$ (SE $70.0$).] Calibration is nearly identical, with Brier $\approx$ 0.066 across the board. Your prior matters a lot here and has clear-cut consequences, as the models agree about the past but disagree strongly about the future. The current data on METR's Github doesn't include GPT-5.2 at the moment, if your'e missing it.

These curves are fitted using a Bayesian item response theory model described below. Before describing it, let's recall METR's analysis of the time horizon. They proceed in two stages:

1. *Per-model logistic regression.* For each model $i$, fit $P(\text{success}) = \sigma(\beta_i(\log h_i - \log t_j))$ where $t_j$ is human time for task $j$. Here $h_i$ is the task duration where the curve crosses 50%. When $t_j = h_i$, we get $\sigma(0) = 0.5$, a $50\%$ horizon. This gives a "horizon score" $h_i$ per model.

2. *An OLS trend.* Regress $\log h_i$ on release date. The slope gives a doubling time of ~4 months.

This is good modeling and gets the main story right, but there are some non-standard choices. For instance, the slope $\beta_i$ is per-model rather than per-task (which is unusual in item response theory) and Stage 1 uncertainty doesn't propagate into Stage 2 (METR uses the bootstrap). It also treats every task of the same length as equally difficult and only considers one trajectory shape.

In this post I make a joint model, adjust some things to be more in line with standard practice, and ask what happens when you try different trajectory shapes. The post is somewhat technical, but not so god-awful that Claude won't be able to answer any question you have about the methodology. Models are fitted with Stan, 4 chains $\times$ 1000 post-warmup draws, with code available [here](https://github.com/JonasMoss/metr-stats). I intentionally won't go into details about technicalities, e.g. prior choices -- the code contains everything you'll want to know and your favorite LLM will figure it out for you. (All priors were chosen by Codex / Claude Code and appear reasonable enough.)

## The basic model 

The first stage of METR's model is *almost* a 2-parameter logistic model (2PL), the workhorse of educational testing since the 1960s.

So, what kind of problems was the 2PL model designed for? Say you give 200 students a math exam with 50 questions and record their answers as correct / incorrect. You want to estimate the students' math ability, but raw percent correct scores aren't necessarily very good, as they depend on which questions (easy or hard? relative to which students?) happened to be on the exam.

The 2PL model solves this by giving each student a single ability score ($\theta_i$) and each question two parameters: a *difficulty* ($b_j$, how hard it is) and a *discrimination* ($a_j$, how cleanly it separates strong from weak students). "What is 3×2?" has low discrimination as everyone gets it right regardless of ability. A simple proof-writing question has high discrimination as sufficiently strong students can solve it, but weak students have no chance.  

The model estimates all parameters simultaneously via a logistic regression:

$$
P(\text{success} \mid \text{model } i, \text{task } j) = \text{logit}^{-1}\bigl(a_j (\theta_i - b_j)\bigr)
$$

This matters here because METR tasks are like exam questions. They vary in both difficulty and how well they separate strong from weak models, and we want to put all the models on a common ability scale.

## Modeling difficulty

Ability and difficulty parameters $\theta_i, b_j$ in the 2PL are hard to interpret. The scale is arbitrary, and it's not clear what, for instance, a 0.1 increase in ability actually means. Or whether it would be better to take a log-transform of the parameter, etc. The METR data is cool and and famous because each task comes with a human time, which gives us a natural and interpretable scale for difficulty. So let's connect human time to difficulty first.

$$
b_j \sim \mathcal{N}(\alpha + \kappa \cdot \log t_j, \;\sigma_b)
$$

Each task's difficulty has a mean that depends on log human time, plus a random component to account for the fact that same-length tasks are not born equal. (METR treats all tasks of identical length as equally hard.)

Since difficulty increases with log human time at rate $\kappa$, we can convert any difficulty value back into a time. Call it the *equivalent difficulty time*. If a task takes humans 10 minutes but is unusually hard for AI, its equivalent difficulty time might be 50 minutes, meaning it's as hard as a typical 50-minute task. Formally, a task with human time $t$ and difficulty residual $u$ has equivalent difficulty time $t \cdot \exp(u / \kappa)$.

I estimate $\sigma_b \approx$ `{python} f"{sigma_b_q50:.2f}"` (posterior median), which is quite large once we interpret it. One standard deviation of unexplained difficulty corresponds to a ~`{python} f"{difficulty_time_mult:.1f}"`x multiplier in equivalent difficulty time.^[The multiplier is $\exp(\sigma_b / \kappa)$ where $\kappa \approx 0.93$ is the posterior median] A task that's $1\sigma$ harder than average for its length is as hard as a typical task `{python} f"{difficulty_time_mult:.1f}"`x longer. A task that's $2\sigma$ harder is as hard as a typical task roughly `{python} f"{np.exp(2 * sigma_b_q50 / kappa_q50):.0f}"`x longer, so tasks of identical human time can span a huge range in actual difficulty for AI.

Of course, this is a modeling choice that can be wrong. There's no guarantee that difficulty is linear in $\log t_j$, so we need diagnostics to check. The plot below does double duty as model diagnostic and explanation of what the random effect means in practice.

```{python}
# | label: fig-difficulty-variation
# | fig-cap: "Each dot is a task. The y-axis shows how much harder or easier the task is than a typical task of the same human time, expressed as a multiplier in equivalent task time. Shaded bands show ±1σ and ±2σ."
# | echo: false

resid = pd.read_csv(diagdir("time_irt__theta_linear") / "difficulty_residuals.csv")

# Transform to interpretable axes
t_hours = np.exp(resid["x"].values + mean_log_t_hours)
t_minutes = t_hours * 60
time_multiplier = np.exp(resid["u_hat"].values / kappa_q50)

time_mult_1sig = difficulty_time_mult
time_mult_2sig = np.exp(2 * sigma_b_q50 / kappa_q50)

fig, ax = plt.subplots(figsize=(8, 4.5))

ax.scatter(t_minutes, time_multiplier, s=18, alpha=0.45, color="C0", edgecolors="none")
ax.axhline(1.0, color="gray", linestyle="--", linewidth=0.8, alpha=0.6)

# ±1σ band
ax.axhspan(1 / time_mult_1sig, time_mult_1sig, color="C0", alpha=0.06, zorder=0)
ax.axhline(time_mult_1sig, color="C0", linewidth=0.7, alpha=0.35, linestyle=":")
ax.axhline(1 / time_mult_1sig, color="C0", linewidth=0.7, alpha=0.35, linestyle=":")

# ±2σ band
ax.axhspan(1 / time_mult_2sig, time_mult_2sig, color="C0", alpha=0.03, zorder=0)
ax.axhline(time_mult_2sig, color="C0", linewidth=0.5, alpha=0.25, linestyle=":")
ax.axhline(1 / time_mult_2sig, color="C0", linewidth=0.5, alpha=0.25, linestyle=":")

# Annotations
xmax = max(t_minutes) * 1.5
ax.text(xmax, time_mult_1sig, f"  +1σ = {time_mult_1sig:.1f}x",
        va="center", fontsize=8, color="C0", alpha=0.7)
ax.text(xmax, 1 / time_mult_1sig, f"  −1σ = {1/time_mult_1sig:.2f}x",
        va="center", fontsize=8, color="C0", alpha=0.7)
ax.text(xmax, time_mult_2sig, f"  +2σ = {time_mult_2sig:.0f}x",
        va="center", fontsize=8, color="C0", alpha=0.7)

ax.set_xscale("log")
ax.set_yscale("log")

tick_minutes = [1/60, 0.5, 1, 5, 10, 30, 60, 4*60, 8*60]
tick_labels = ["1 sec", "30 sec", "1 min", "5 min", "10 min", "30 min", "1 hr", "4 hr", "8 hr"]
ax.set_xticks(tick_minutes)
ax.set_xticklabels(tick_labels, fontsize=8)
ax.set_xlim(min(t_minutes) * 0.5, max(t_minutes) * 2)

yticks = [1/time_mult_2sig, 1/time_mult_1sig, 0.5, 1.0, 2.0, time_mult_1sig, time_mult_2sig]
ax.set_yticks(yticks)
ax.set_yticklabels([f"{y:.1f}x" if y >= 0.1 else f"{y:.2f}x" for y in yticks], fontsize=8)

ax.set_xlabel("Human time-to-complete")
ax.set_ylabel("Difficulty multiplier\n(1x = average for this task length)")
ax.grid(True, which="major", axis="y", linestyle="--", linewidth=0.5, alpha=0.2)

fig.tight_layout()
plt.show()
```

The y-axis is the difficulty multiplier from above. A dot at 5x means the task's equivalent difficulty time is 5x its actual human time. Even within the ±1σ band, tasks of identical human time can differ multiplicatively by a factor of `{python} f"{difficulty_time_mult**2:.0f}"`x in equivalent difficulty, so the practical spread is enormous.

There's not too much curvature in the relationship between log human time and difficulty, so I think the log-linear form is decent, but it's much more spread out than we'd like. There is a cluster of easy outliers on the far left, which I think can be explained by very short tasks containing virtually no information about difficulty. Overall this looks reasonable for modeling purposes.

## Modeling ability over time

By directly modeling ability over time, we can try out shapes like exponential, subexponential, superexponential, saturating, and singularity. Forecasts depend a lot on which shape you pick, and the data doesn't really tell you much, so it's not easy to choose between them. Your priors rule here.

The abilities are modeled as
$$
\theta_i \sim \mathcal{N}\bigl(f(x_i;\, \gamma),\; \sigma_\theta\bigr)
$$

where $x_i$ is the model release date in years, centered at the mean (September 2024). I'm still using a random effect for model ability here, since nobody seriously thinks every model released on the same date must be equally capable. I'm looking at four shapes for $f$:^[Quadratic is the simplest choice of superexponential function. You could spin a story in its favor, but using it is somewhat arbitrary. The power-law is the simplest function that can be both super- and subexponential (in practice turns out to be superexponential here though), and I included the saturating model because, well, why not?]

| Model | $f(x)$ | Params | Intuition |
|:------|:-------|:------:|:----------|
| Linear | $\gamma_0 + \gamma_1 x$ | 2 | Linear $\theta$ = exponential horizon growth (constant doubling time) |
| Quadratic | $\gamma_0 + \gamma_1 x + \gamma_2 x^2$, $\gamma_2 \geq 0$ | 3 | Superexponential, accelerating growth |
| Power-law | $\gamma_0 + \gamma_1 \tilde{x}^{\alpha}$, $\alpha \in [0.1, 2]$ | 3 | Flexible: sub- or super-exponential. $\tilde{x}$ is a shifted/scaled version of $x$. |
| Saturating | $\theta_{\min} + \Delta\theta \cdot \text{logit}^{-1}(a + bx)$ | 4 | S-curve ceiling on ability. |

If METR's GitHub repo contained all the historical data, I would also have tried a piecewise linear with a breakpoint around the time of o1, which visually fits the original METR graphs better than a plain linear fit. But since the available data doesn't go that far back, I don't need to, and the value of including those early points in a forecasting exercise is questionable anyway. Getting hold of the latest data points is more important.

All models share the same 2PL likelihood and task parameters ($b_j$, $a_j$,
$\alpha$, $\kappa$, $\sigma_b$). Only the model for $\theta$ changes.

Each model except the saturating model will cross any threshold given enough time. Here are posteriors for the 50% crossing across our models. The saturating model almost never crosses the 1-month and 125-year thresholds since it saturates too fast. 

```{python}
# | echo: false
# | label: tbl-horizon-crossing
# | tbl-cap: "Predicted crossing dates for two horizon thresholds (1 month and 125 years), by trajectory model."

from IPython.display import Markdown


def _to_ym(date_str):
    """Round a YYYY-MM-DD string to nearest month, return YYYY-MM."""
    if not date_str or pd.isna(date_str) or date_str == "---":
        return "---"
    d = pd.to_datetime(date_str)
    if d.day >= 15:
        d = d + pd.offsets.MonthBegin(1)
    return d.strftime("%Y-%m")


labels = {
    "linear": "Linear",
    "quadratic_pos": "Quadratic",
    "xpow": "Power-law",
}


def _fmt_row(r):
    frac = r["frac_crossing"]
    if frac < 0.01 or pd.isna(r["mean_date"]):
        return "---", "---"
    lo = _to_ym(r["ci95_low"]) if pd.notna(r["ci95_low"]) else ""
    hi = _to_ym(r["ci95_high"]) if pd.notna(r["ci95_high"]) else ""
    cri = f"{lo} -- {hi}" if lo and hi else "---"
    return _to_ym(r["mean_date"]), cri


df1m = pd.read_csv("blog/_generated/one_month_horizon.csv")
df125 = pd.read_csv("blog/_generated/125y_horizon.csv")

rows = []
for _, r1 in df1m.iterrows():
    trend = r1["theta_trend"]
    if trend not in labels:
        continue
    label = labels[trend]
    d1, c1 = _fmt_row(r1)
    r125 = df125[df125["theta_trend"] == trend]
    if len(r125):
        d2, c2 = _fmt_row(r125.iloc[0])
    else:
        d2, c2 = "---", "---"
    rows.append((label, d1, c1, d2, c2))

html50 = '<table style="width:100%">\n<thead>\n'
html50 += '<tr><th rowspan="2">Trend</th>'
html50 += '<th colspan="2" style="text-align:center;border-bottom:none">1 month</th>'
html50 += '<th colspan="2" style="text-align:center;border-bottom:none">125 years</th></tr>\n'
html50 += '<tr><th>Mean</th><th>95% CrI</th><th>Mean</th><th>95% CrI</th></tr>\n'
html50 += '</thead>\n<tbody>\n'
for label, d1, c1, d2, c2 in rows:
    html50 += f'<tr><td>{label}</td><td>{d1}</td><td>{c1}</td><td>{d2}</td><td>{c2}</td></tr>\n'
html50 += '</tbody>\n</table>'
Markdown(html50)
```


## Problems with 80% success

Everything above uses 50% success, but METR also cares about 80% success and fits a separate model for that. We don't need to do that here since the model estimation doesn't really depend on success rates at all. We'll just calculate the 80%-success horizon using posterior draws instead.

But there are actually two reasonable ways to define "80% success," and they give different answers.

1. *Typical:* Pick a task of average difficulty for its length. Can the model solve it 80% of the time? This is roughly what METR computes.

2. *Marginal:* Pick a random task of that length. What's the expected success rate? Because some tasks are much harder than average, the hard ones drag down the average more than easy ones push it up.

At 50%, the two definitions agree exactly. But at 80%, the gap is roughly an order of magnitude! 

```{python}
# | label: fig-marginal-typical
# | fig-cap: "Horizon forecasts at 80% success probability. Left: linear trajectory. Right: quadratic (constrained)."
# | echo: false

panel_specs = [
    ("Linear", "time_irt__theta_linear"),
    ("Quadratic", "time_irt__theta_quadratic_pos"),
]
x_max = pd.Timestamp("2029-01-01")

fig, axes = plt.subplots(1, 2, figsize=(9.5, 4.0), sharey=True)

for ax, (panel_label, spec_name) in zip(axes, panel_specs):
    marg = load_horizon_grid(spec_name, kind="marginal")
    typ = load_horizon_grid(spec_name, kind="typical")

    # 50% (marginal ≈ typical) — thin reference.
    g50 = marg.query("p == 0.5").sort_values("date")
    g50 = g50[g50["date"] <= x_max]
    ax.plot(
        g50["date"], g50["t_hours_q50"], color="0.6", linewidth=1.2, label="50% success"
    )
    ax.fill_between(
        g50["date"], g50["t_hours_q025"], g50["t_hours_q975"], color="0.6", alpha=0.06
    )

    # 80% typical.
    g80t = typ.query("p == 0.8").sort_values("date")
    g80t = g80t[g80t["date"] <= x_max]
    ax.plot(
        g80t["date"], g80t["t_hours_q50"], color="C0", linewidth=2, label="80% typical"
    )
    ax.fill_between(
        g80t["date"], g80t["t_hours_q025"], g80t["t_hours_q975"], color="C0", alpha=0.10
    )

    # 80% marginal.
    g80m = marg.query("p == 0.8").sort_values("date")
    g80m = g80m[g80m["date"] <= x_max]
    ax.plot(
        g80m["date"],
        g80m["t_hours_q50"],
        color="C3",
        linewidth=2,
        linestyle="--",
        label="80% marginal",
    )
    ax.fill_between(
        g80m["date"], g80m["t_hours_q025"], g80m["t_hours_q975"], color="C3", alpha=0.10
    )

    # Model-specific horizon points at 80%.
    pts_typ = load_horizon_points(spec_name, kind="typical").query("p == 0.8")
    pts_marg = load_horizon_points(spec_name, kind="marginal").query("p == 0.8")
    ax.errorbar(
        pts_typ["release_date"],
        pts_typ["t_hours_q50"],
        yerr=np.vstack(
            [
                pts_typ["t_hours_q50"] - pts_typ["t_hours_q025"],
                pts_typ["t_hours_q975"] - pts_typ["t_hours_q50"],
            ]
        ),
        fmt="o",
        color="C0",
        ecolor="C0",
        elinewidth=1.2,
        capsize=2,
        alpha=0.6,
        zorder=5,
        markersize=4,
    )
    ax.errorbar(
        pts_marg["release_date"],
        pts_marg["t_hours_q50"],
        yerr=np.vstack(
            [
                pts_marg["t_hours_q50"] - pts_marg["t_hours_q025"],
                pts_marg["t_hours_q975"] - pts_marg["t_hours_q50"],
            ]
        ),
        fmt="s",
        color="C3",
        ecolor="C3",
        elinewidth=1.2,
        capsize=2,
        alpha=0.6,
        zorder=5,
        markersize=4,
    )

    ax.axhline(
        30 * 24, color="red", linestyle="--", alpha=0.3, linewidth=1, label="1 month"
    )

    ax.set_yscale("log")
    ax.set_title(panel_label, fontsize=12)
    ax.set_xlim(pd.Timestamp("2023-01-01"), x_max)
    ax.set_ylim(1e-3, 365 * 24)
    ax.xaxis.set_major_locator(mdates.YearLocator())
    ax.xaxis.set_major_formatter(mdates.DateFormatter("%Y"))

    tick_hours = np.array(
        [1 / 60, 6 / 60, 1.0, 10.0, 4 * 24.0, 30 * 24.0, 6 * 30 * 24.0]
    )
    ax.set_yticks(tick_hours)
    ax.set_yticklabels([_format_duration_hours(float(t)) for t in tick_hours])
    ax.grid(True, which="major", axis="y", linestyle="--", linewidth=0.8, alpha=0.25)

axes[0].set_ylabel("")
axes[0].legend(fontsize=7.5, loc="upper left")
axes[1].set_xlabel("Release date")
axes[0].set_xlabel("Release date")
fig.tight_layout()
plt.show()
```

So, on the one hand, it's the variance ($\sigma_b \approx 1.44$) alone that causes these two plots to be necessary under our model. But on the other hand, the difference is not really a consequence of modeling. Some tasks of the same human time vary a lot in how hard they are for our models, and a phenomenon like this would happen for *any* model that's actually honest about this.

The marginal horizon is the one that matters for practical purposes. "Typical" is optimistic since it only considers tasks of average difficulty for their length. The marginal accounts for the full spread of tasks, so it's what you actually care about when predicting success on a random task of some length. That said, from the plot we see frontier performance of roughly `{python} f"{frontier_80_marg_minutes:.0f}"` minutes, which does sound sort of short to me. I'm used to LLMs roughly one-shotting longer tasks than that, but it usually takes some iterations to get it just right. Getting the context and subtle intentions right on the first try is hard, so I'm willing to believe this estimate is reasonable.

Anyway, the predicted crossing dates at 80% success are:

```{python}
# | echo: false
# | label: tbl-horizon-80-1mo
# | tbl-cap: "Predicted date when the 80%-success horizon reaches 1 month. The saturating model is omitted (almost never crosses)."

df_typ_1m = pd.read_csv("blog/_generated/one_month_horizon_p80_typical.csv")
df_marg_1m = pd.read_csv("blog/_generated/one_month_horizon_p80_marginal.csv")

_labels80 = {
    "linear": "Linear",
    "quadratic_pos": "Quadratic",
    "xpow": "Power-law",
}

def _get80(df, trend):
    sub = df[df["theta_trend"] == trend]
    if not len(sub):
        return "---", "---"
    r = sub.iloc[0]
    if r["frac_crossing"] < 0.01 or pd.isna(r["mean_date"]):
        return "---", "---"
    lo = _to_ym(r["ci95_low"]) if pd.notna(r["ci95_low"]) else ""
    hi = _to_ym(r["ci95_high"]) if pd.notna(r["ci95_high"]) else ""
    cri = f"{lo} -- {hi}" if lo and hi else "---"
    return _to_ym(r["mean_date"]), cri

rows_1m = []
for trend, label in _labels80.items():
    td, tc = _get80(df_typ_1m, trend)
    md, mc = _get80(df_marg_1m, trend)
    rows_1m.append((label, td, tc, md, mc))

h = '<table style="width:100%">\n<thead>\n'
h += '<tr><th rowspan="2">Trend</th>'
h += '<th colspan="2" style="text-align:center;border-bottom:none">Typical</th>'
h += '<th colspan="2" style="text-align:center;border-bottom:none">Marginal</th></tr>\n'
h += '<tr><th>Mean</th><th>95% CrI</th><th>Mean</th><th>95% CrI</th></tr>\n'
h += '</thead>\n<tbody>\n'
for label, td, tc, md, mc in rows_1m:
    h += f'<tr><td>{label}</td><td>{td}</td><td>{tc}</td><td>{md}</td><td>{mc}</td></tr>\n'
h += '</tbody>\n</table>'
Markdown(h)
```

```{python}
# | echo: false
# | label: tbl-horizon-80-125y
# | tbl-cap: "Predicted date when the 80%-success horizon reaches 125 years. The saturating model is omitted (never crosses)."

df_typ_125 = pd.read_csv("blog/_generated/125y_horizon_p80_typical.csv")
df_marg_125 = pd.read_csv("blog/_generated/125y_horizon_p80_marginal.csv")

rows_125 = []
for trend, label in _labels80.items():
    td, tc = _get80(df_typ_125, trend)
    md, mc = _get80(df_marg_125, trend)
    rows_125.append((label, td, tc, md, mc))

h2 = '<table style="width:100%">\n<thead>\n'
h2 += '<tr><th rowspan="2">Trend</th>'
h2 += '<th colspan="2" style="text-align:center;border-bottom:none">Typical</th>'
h2 += (
    '<th colspan="2" style="text-align:center;border-bottom:none">Marginal</th></tr>\n'
)
h2 += "<tr><th>Mean</th><th>95% CrI</th><th>Mean</th><th>95% CrI</th></tr>\n"
h2 += "</thead>\n<tbody>\n"
for label, td, tc, md, mc in rows_125:
    h2 += f"<tr><td>{label}</td><td>{td}</td><td>{tc}</td><td>{md}</td><td>{mc}</td></tr>\n"
h2 += "</tbody>\n</table>"
Markdown(h2)
```

Make of this what you will, but let's go through one scenario. Let's say I'm a believer in superexponential models with no preference between quadratic and power-law, so I have 50-50 weighting on those. Suppose also I believe that 125 years is the magic number for the auto-coder of [AI Futures](https://www.aifuturesmodel.com/), but I prefer $80\%$ to $50\%$ as the latter is too brittle. Then, using the arguably correct marginal formulation, my timeline has mean roughly `{python} scenario_marg_str`, but the typical framework yields roughly `{python} scenario_typ_str` instead. And this isn't too bad, just a difference of ~`{python} f"{scenario_diff_years:.1f}"` years! The linear model is similar, with timelines pushed out roughly `{python} f"{linear_diff_years:.1f}"` years. So, the wide marginal-typical gap doesn't translate into *that* big timeline gaps, as both trajectories have the same "slope", just at a different level.

Let's also have a look at METR's actual numbers. They report an 80% horizon of around `{python} f"{_metr_sonnet37_80_min:.0f}"` minutes for Claude 3.7 Sonnet (in the original paper). Our typical 80% horizon for that model under the linear trend is about `{python} f"{sonnet37_typ_min:.1f}"` min, and the marginal is about `{python} f"{sonnet37_marg_min:.1f}"` min---roughly `{python} f"{_metr_sonnet37_80_min / sonnet37_marg_min:.0f}"`x shorter than METR's. Recall that METR's methodology doesn't model task-level difficulty variation at all, so their 80% horizon effectively reflects the typical tasks at each length rather than a random draw.

## Modeling $t_j$

The available METR data contains the geometric mean of (typically 2-3 for HCAST) successful human baselines per task, but not the individual times. Both METR's analysis and mine treat this reported mean as a known quantity, discarding uncertainty. But we can model $t_j$ as a latent variable informed by the reported baselines. This is easy enough to do in Stan, and would give a more honest picture of what the data actually supports, as all credible intervals will be widened. 

I'd expect smaller differences between the typical and marginal plots at $80\%$ horizon if the $t_j$ values were modeled properly, as more of the variance in the random effect would be absorbed by the uncertainty in $t_j$. I'm not sure how big the effect would be, but getting hold of the data or doing a short simulation would help.  

A technical point: When modeling $t_j$, I would also try a Weibull distribution instead of log-normal, since the log-normal is typically heavier-tailed and the Weibull is easier to justify on theoretical grounds using its failure-rate interpretation.

## Notes and remarks

* I also tried a finite-time singularity model of the form $\theta \sim \gamma_0 + \gamma_1 x + c / (t^* - x)^\alpha$. The posterior on the singularity date $t^*$ didn't really move from the prior at all. This is no surprise. It just means the data is uninformative about $t^\star$.
* There are loads of other knobs you could turn. Perhaps you could introduce a discrimination parameter that varies by model and task, together with a hierarchical prior. Perhaps you could make discrimination a function of time, etc. I doubt any of these would change the picture much, if at all. The model fit is good enough as it is, even if the uncertainty is likely too small. That said, I don't want to dissuade anyone from trying!
* The power-law model does in principle support both sub- and superexponential trajectories ($\alpha < 1$ and $\alpha > 1$, respectively, where $\alpha = 1$ is the linear model). The posterior puts $P(\alpha < 1) \approx 4\%$, so the data does not support subexponential growth. At least when using this model.
* There's plenty of best-practice stuff I haven't done, such as prior sensitivity analysis. (But we have a lot of data, and I wouldn't expect it to matter too much.) 
* The doubling time posterior median is `{python} f"{dt_q50:.1f}"` months (95% credible interval: `{python} f"{dt_q025:.1f}"`--`{python} f"{dt_q975:.1f}"`), which is close to METR's v1.1 estimate. Of course, doubling time only makes sense for the linear model above, as the doubling time of the other models varies with time.

```{python}
# | label: fig-doubling-time
# | fig-cap: "Posterior distribution of the horizon doubling time under the linear model."
# | echo: false

from scipy.stats import gaussian_kde

draws = pd.read_csv(figdir("time_irt__theta_linear") / "doubling_time_draws.csv")
dt_months = draws["doubling_time_years"].values * 12

kde = gaussian_kde(dt_months, bw_method="silverman")
x = np.linspace(dt_months.min() - 0.3, dt_months.max() + 0.3, 400)

q025, q50, q975 = np.percentile(dt_months, [2.5, 50, 97.5])

fig, ax = plt.subplots(figsize=(7, 3.2))
ax.fill_between(x, kde(x), alpha=0.15, color="C0")
ax.plot(x, kde(x), color="C0", linewidth=2)
ax.axvline(q50, color="black", linewidth=1.5, label=f"Median = {q50:.1f} months")
ax.axvline(
    q025,
    color="black",
    linewidth=1,
    linestyle="--",
    alpha=0.6,
    label=f"95% CrI: [{q025:.1f}, {q975:.1f}]",
)
ax.axvline(q975, color="black", linewidth=1, linestyle="--", alpha=0.6)
ax.set_xlabel("Doubling time (months)")
ax.set_ylabel("Posterior density")
ax.legend(fontsize=9)
fig.tight_layout()
plt.show()
```


